#!/bin/sh
# =================================================================
# OpenResty SSL Certificate Initialization Script
# Handles SSL/TLS certificates for HTTPS. JWT keys are managed by
# blockchain-services entrypoint separately.
# =================================================================

SSL_DIR="/etc/ssl/private"
CERT_FILE="$SSL_DIR/fullchain.pem"
KEY_FILE="$SSL_DIR/privkey.pem"
TEMP_SSL_DIR="/tmp/ssl"
RENEW_THRESHOLD_SECONDS=$((30 * 24 * 3600))  # 30 days (ACME renewal threshold)
SELF_SIGNED_RENEW_THRESHOLD=$((10 * 24 * 3600))  # 10 days (self-signed regeneration threshold)
SELF_SIGNED_MARKER="$SSL_DIR/.selfsigned_issued"
SELF_SIGNED_MAX_AGE_SECONDS=$((85 * 24 * 3600))  # 85 days (rotate before 90-day expiry)
CERTBOT_WEBROOT="/var/www/certbot"

echo "=== OpenResty SSL Certificate Check ==="
echo "Certificate: $CERT_FILE"
echo "Private Key: $KEY_FILE"

# Create SSL directory if it doesn't exist
mkdir -p "$SSL_DIR"

generate_self_signed() {
    echo "SSL certificates missing or expiring - generating self-signed certificates for development"
    mkdir -p "$TEMP_SSL_DIR"
    cat > "$TEMP_SSL_DIR/openssl.conf" << EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = ES
ST = Development
L = Local
O = DecentraLabs
OU = Development
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
IP.1 = 127.0.0.1
EOF

    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout "$TEMP_SSL_DIR/privkey.pem" \
        -out "$TEMP_SSL_DIR/fullchain.pem" \
        -config "$TEMP_SSL_DIR/openssl.conf" \
        -extensions v3_req

    # NOTE: JWT keys (private_key.pem, public_key.pem) are generated by
    # blockchain-services entrypoint, not here. OpenResty only needs SSL certs.

    if [ -f "$TEMP_SSL_DIR/fullchain.pem" ] && [ -f "$TEMP_SSL_DIR/privkey.pem" ]; then
        cp "$TEMP_SSL_DIR/fullchain.pem" "$CERT_FILE"
        cp "$TEMP_SSL_DIR/privkey.pem" "$KEY_FILE"
        chmod 644 "$CERT_FILE"
        chmod 600 "$KEY_FILE"
        date +%s > "$SELF_SIGNED_MARKER" 2>/dev/null || true
        echo "✔ Self-signed SSL certificates generated successfully"
        echo "   Valid for: localhost, *.localhost, 127.0.0.1"
        echo "   WARNING: These are self-signed certificates for development only!"
    else
        echo "✖ Failed to generate certificates - this will cause nginx startup failure"
        exit 1
    fi
}

is_localhost_self_signed() {
    subj=$(openssl x509 -in "$CERT_FILE" -noout -subject 2>/dev/null || echo "")
    issuer=$(openssl x509 -in "$CERT_FILE" -noout -issuer 2>/dev/null || echo "")
    echo "$subj" | grep -q "CN=localhost" && echo "$issuer" | grep -q "CN=localhost"
}

is_acme_cert() {
    # Check if certificate is issued by Let's Encrypt or other ACME CA
    issuer=$(openssl x509 -in "$CERT_FILE" -noout -issuer 2>/dev/null || echo "")
    echo "$issuer" | grep -qiE "(Let's Encrypt|R3|R4|E1|E2|ISRG|ZeroSSL)"
}

get_cert_days_until_expiry() {
    end_date=$(openssl x509 -in "$CERT_FILE" -noout -enddate 2>/dev/null | sed 's/notAfter=//')
    if [ -z "$end_date" ]; then
        echo "0"
        return
    fi
    end_epoch=$(date -d "$end_date" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$end_date" +%s 2>/dev/null || echo "0")
    now_epoch=$(date +%s)
    days=$(( (end_epoch - now_epoch) / 86400 ))
    echo "$days"
}

renew_acme_cert() {
    if [ -z "${CERTBOT_DOMAINS:-}" ] || [ -z "${CERTBOT_EMAIL:-}" ]; then
        echo "ACME renewal skipped: CERTBOT_DOMAINS or CERTBOT_EMAIL not set"
        return 1
    fi
    
    echo "Attempting ACME certificate renewal..."
    mkdir -p "$CERTBOT_WEBROOT"
    
    # Try renewal first (faster if cert exists)
    if certbot renew --webroot -w "$CERTBOT_WEBROOT" --quiet --deploy-hook "echo 'Certificate renewed successfully'" 2>/dev/null; then
        echo "✔ ACME certificate renewed via certbot renew"
        return 0
    fi
    
    # If renewal fails, try obtaining a new cert
    domain_args=""
    for domain in $(echo "$CERTBOT_DOMAINS" | tr ',' ' '); do
        domain_args="$domain_args -d $domain"
    done
    
    if certbot certonly --webroot -w "$CERTBOT_WEBROOT" \
        $domain_args \
        --email "$CERTBOT_EMAIL" \
        --agree-tos --non-interactive --quiet 2>/dev/null; then
        
        # Copy new certs to expected location
        primary_domain=$(echo "$CERTBOT_DOMAINS" | cut -d',' -f1)
        cp "/etc/letsencrypt/live/$primary_domain/fullchain.pem" "$CERT_FILE"
        cp "/etc/letsencrypt/live/$primary_domain/privkey.pem" "$KEY_FILE"
        chmod 644 "$CERT_FILE"
        chmod 600 "$KEY_FILE"
        echo "✔ ACME certificate obtained and installed"
        return 0
    fi
    
    echo "✖ ACME certificate renewal failed"
    return 1
}

# Check if certificates exist or need renewal
if [ ! -f "$CERT_FILE" ] || [ ! -f "$KEY_FILE" ]; then
    # Try ACME first if configured
    if [ -n "${CERTBOT_DOMAINS:-}" ] && [ -n "${CERTBOT_EMAIL:-}" ]; then
        if ! renew_acme_cert; then
            echo "ACME failed, falling back to self-signed"
            generate_self_signed
        fi
    else
        generate_self_signed
    fi
else
    echo "✔ SSL certificates found"
    days_left=$(get_cert_days_until_expiry)
    echo "   Days until expiry: $days_left"
    
    if is_acme_cert; then
        # ACME cert: renew at 30 days before expiry
        if [ "$days_left" -lt 30 ]; then
            echo "   Status: ACME certificate expires in less than 30 days. Renewing..."
            if renew_acme_cert; then
                echo "   ACME certificate renewed successfully"
            else
                echo "   Warning: ACME renewal failed - will retry later"
            fi
        else
            echo "   Status: Valid ACME certificate"
        fi
    elif is_localhost_self_signed; then
        # Self-signed cert: regenerate at 10 days before expiry
        if [ "$days_left" -lt 10 ]; then
            echo "   Status: Self-signed certificate expiring soon. Regenerating..."
            generate_self_signed
        else
            echo "   Status: Valid self-signed certificate"
        fi
    else
        # User-provided cert: warn but don't replace
        if [ "$days_left" -lt 30 ]; then
            echo "   ⚠ Warning: User-provided certificate expires in $days_left days!"
            echo "   Please renew manually or configure CERTBOT_DOMAINS and CERTBOT_EMAIL"
        else
            echo "   Status: Valid user-provided certificate"
        fi
    fi
fi

# Wait for JWT public key (generated by blockchain-services)
JWT_PUBLIC_KEY="$SSL_DIR/public_key.pem"
echo "=== Waiting for JWT public key ==="
echo "Expected: $JWT_PUBLIC_KEY"
wait_count=0
max_wait=60  # 60 seconds max
while [ ! -f "$JWT_PUBLIC_KEY" ] && [ $wait_count -lt $max_wait ]; do
    echo "Waiting for blockchain-services to generate JWT keys... (${wait_count}s)"
    sleep 2
    wait_count=$((wait_count + 2))
done

if [ -f "$JWT_PUBLIC_KEY" ]; then
    echo "✔ JWT public key found"
else
    echo "⚠ JWT public key not found after ${max_wait}s - JWT validation will fail until key is available"
    echo "  blockchain-services should generate it on startup"
fi

echo "=== Starting OpenResty ==="

# Export environment variables that nginx needs to access
export LAB_MANAGER_TOKEN="${LAB_MANAGER_TOKEN:-}"

# Background watcher: reload OpenResty if cert/key change on disk
watch_certs() {
    last_cert_ts=$(stat -c %Y "$CERT_FILE" 2>/dev/null || stat -f %m "$CERT_FILE" 2>/dev/null || echo 0)
    last_key_ts=$(stat -c %Y "$KEY_FILE" 2>/dev/null || stat -f %m "$KEY_FILE" 2>/dev/null || echo 0)
    while true; do
        sleep 43200  # 12h
        cert_ts=$(stat -c %Y "$CERT_FILE" 2>/dev/null || stat -f %m "$CERT_FILE" 2>/dev/null || echo 0)
        key_ts=$(stat -c %Y "$KEY_FILE" 2>/dev/null || stat -f %m "$KEY_FILE" 2>/dev/null || echo 0)
        if [ "$cert_ts" != "$last_cert_ts" ] || [ "$key_ts" != "$last_key_ts" ]; then
            echo "Certificate/key changed on disk. Reloading OpenResty..."
            /usr/local/openresty/bin/openresty -s reload || true
            last_cert_ts="$cert_ts"
            last_key_ts="$key_ts"
        fi
    done
}

watch_certs &

auto_rotate_self_signed() {
    # Only rotate self-signed certs when ACME is not configured
    if [ -n "${CERTBOT_DOMAINS:-}" ] && [ -n "${CERTBOT_EMAIL:-}" ]; then
        return
    fi
    while true; do
        sleep 86400  # daily check
        if ! is_localhost_self_signed; then
            continue
        fi
        issued_ts=$(cat "$SELF_SIGNED_MARKER" 2>/dev/null || echo 0)
        now_ts=$(date +%s)
        age=$((now_ts - issued_ts))
        if [ "$age" -ge "$SELF_SIGNED_MAX_AGE_SECONDS" ]; then
            echo "Self-signed certificate older than 85 days - rotating..."
            generate_self_signed
            /usr/local/openresty/bin/openresty -s reload || true
        fi
    done
}

auto_rotate_self_signed &

# Background ACME renewal watcher (runs twice daily for Let's Encrypt best practices)
auto_renew_acme() {
    if [ -z "${CERTBOT_DOMAINS:-}" ] || [ -z "${CERTBOT_EMAIL:-}" ]; then
        return
    fi
    while true; do
        sleep 43200  # 12 hours
        if ! is_acme_cert; then
            continue
        fi
        days_left=$(get_cert_days_until_expiry)
        if [ "$days_left" -lt 30 ]; then
            echo "ACME certificate expires in $days_left days - attempting renewal..."
            if renew_acme_cert; then
                echo "ACME certificate renewed. Reloading OpenResty..."
                /usr/local/openresty/bin/openresty -s reload || true
            fi
        fi
    done
}

auto_renew_acme &

exec /usr/local/openresty/bin/openresty -g "daemon off;"
